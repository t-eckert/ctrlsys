# Timer Microservice Tasks

version: '3'

vars:
  SERVICE_NAME: timer-service
  IMAGE_TAG: '{{.IMAGE_TAG | default "latest"}}'
  REGISTRY: '{{.REGISTRY | default "your-registry"}}'

tasks:
  # Build tasks
  build:
    desc: "Build timer service"
    deps: [proto:generate]
    cmds:
      - cargo build

  build:release:
    desc: "Build timer service (release)"
    deps: [proto:generate]
    cmds:
      - cargo build --release

  # Test tasks
  test:
    desc: "Run timer tests"
    cmds:
      - cargo test

  test:integration:
    desc: "Run integration tests"
    cmds:
      - cargo test --test integration

  # Protocol Buffers
  proto:generate:
    desc: "Generate Rust code from protobuf files"
    cmds:
      - cd ../../ && buf generate --template buf.gen.rust.yaml proto/timer
    sources:
      - ../../proto/timer/ctrlsys/timer/v1/*.proto
    generates:
      - ../../gen/rust/ctrlsys/timer/v1/*.rs

  # Code quality
  fmt:
    desc: "Format timer code"
    cmds:
      - cargo fmt

  clippy:
    desc: "Run clippy on timer"
    cmds:
      - cargo clippy -- -D warnings

  check:
    desc: "Check timer (fmt + clippy + test)"
    cmds:
      - task: fmt
      - task: clippy
      - task: test

  # Development
  run:
    desc: "Run timer service locally"
    env:
      TIMER_DURATION_SECONDS: '{{.TIMER_DURATION_SECONDS | default "300"}}'
      CONTROL_PLANE_ENDPOINT: '{{.CONTROL_PLANE_ENDPOINT | default "http://localhost:50053"}}'
      RUST_LOG: '{{.RUST_LOG | default "info"}}'
      TIMER_NAME: '{{.TIMER_NAME | default "dev-timer"}}'
    cmds:
      - cargo run

  run:debug:
    desc: "Run timer service with debug logging"
    env:
      TIMER_DURATION_SECONDS: '{{.TIMER_DURATION_SECONDS | default "60"}}'
      CONTROL_PLANE_ENDPOINT: '{{.CONTROL_PLANE_ENDPOINT | default "http://localhost:50053"}}'
      RUST_LOG: debug
      TIMER_NAME: debug-timer
    cmds:
      - cargo run

  watch:
    desc: "Watch and rebuild timer"
    cmds:
      - cargo watch -x build

  watch:test:
    desc: "Watch and test timer"
    cmds:
      - cargo watch -x test

  # Container tasks
  container:build:
    desc: "Build timer container image"
    cmds:
      - podman build -t {{.SERVICE_NAME}}:{{.IMAGE_TAG}} .

  container:run:
    desc: "Run timer in Podman"
    env:
      TIMER_DURATION_SECONDS: '{{.TIMER_DURATION_SECONDS | default "300"}}'
      CONTROL_PLANE_ENDPOINT: '{{.CONTROL_PLANE_ENDPOINT | default "http://host.containers.internal:50053"}}'
    cmds:
      - podman run --rm -p 50051:50051
        -e TIMER_DURATION_SECONDS=$TIMER_DURATION_SECONDS
        -e CONTROL_PLANE_ENDPOINT=$CONTROL_PLANE_ENDPOINT
        -e RUST_LOG=info
        {{.SERVICE_NAME}}:{{.IMAGE_TAG}}

  container:push:
    desc: "Push timer container image"
    cmds:
      - podman tag {{.SERVICE_NAME}}:{{.IMAGE_TAG}} {{.REGISTRY}}/{{.SERVICE_NAME}}:{{.IMAGE_TAG}}
      - podman push {{.REGISTRY}}/{{.SERVICE_NAME}}:{{.IMAGE_TAG}}

  container:logs:
    desc: "Show container logs"
    cmds:
      - podman logs {{.SERVICE_NAME}}:{{.IMAGE_TAG}} || echo "Container not running"

  container:stop:
    desc: "Stop running timer container"
    cmds:
      - podman stop {{.SERVICE_NAME}} || echo "Container not running"

  # Kubernetes in Docker (using Podman)
  k8s:cluster:start:
    desc: "Start local Kubernetes cluster with Podman"
    cmds:
      - |
        # Check if container exists (running or stopped)
        if podman ps -a --format "{{`{{.Names}}`}}" | grep -q "^kind-control-plane$"; then
          echo "Found existing kind-control-plane container..."
          # Check if it's running
          if podman ps --format "{{`{{.Names}}`}}" | grep -q "^kind-control-plane$"; then
            echo "Kubernetes cluster is already running"
            exit 0
          else
            echo "Starting existing container..."
            podman start kind-control-plane
            echo "Cluster restarted!"
            exit 0
          fi
        fi

        echo "Starting new Kubernetes cluster with kind..."
        podman run -d --name kind-control-plane --privileged \
          -p 6443:6443 \
          --cgroupns=host -v /sys/fs/cgroup:/sys/fs/cgroup:rw \
          kindest/node:v1.27.3

        echo "Waiting for cluster to be ready..."
        sleep 30

        echo "Cluster started!"
        echo "Configure kubectl with:"
        echo "   kubectl config set-cluster kind --server=https://127.0.0.1:6443 --insecure-skip-tls-verify=true"

  k8s:cluster:stop:
    desc: "Stop local Kubernetes cluster"
    cmds:
      - |
        if podman ps -a --format "{{`{{.Names}}`}}" | grep -q "^kind-control-plane$"; then
          echo "Stopping Kubernetes cluster..."
          podman stop kind-control-plane || echo "Already stopped"
          podman rm kind-control-plane || echo "Already removed"
          echo "Cluster stopped and removed"
        else
          echo "No Kubernetes cluster found"
        fi

  k8s:cluster:status:
    desc: "Check Kubernetes cluster status"
    cmds:
      - |
        if podman ps --format "{{`{{.Names}}`}}" | grep -q "^kind-control-plane$"; then
          echo "Kubernetes cluster is running"
          echo "Checking cluster health..."
          if podman exec kind-control-plane kubectl get nodes --no-headers 2>/dev/null | grep -q "Ready"; then
            echo "Cluster is healthy and ready"
            podman exec kind-control-plane kubectl get nodes
          else
            echo "Cluster is starting up or not ready yet"
          fi
        elif podman ps -a --format "{{`{{.Names}}`}}" | grep -q "^kind-control-plane$"; then
          echo "Kubernetes cluster container exists but is not running"
          echo "Run 'task k8s:cluster:start' to start it"
        else
          echo "No Kubernetes cluster found"
          echo "Run 'task k8s:cluster:start' to create one"
        fi

  k8s:cluster:shell:
    desc: "Shell into Kubernetes cluster container"
    cmds:
      - |
        if podman ps --format "{{`{{.Names}}`}}" | grep -q "^kind-control-plane$"; then
          echo "Opening shell in Kubernetes cluster..."
          podman exec -it kind-control-plane bash
        else
          echo "Kubernetes cluster is not running"
          echo "Start it with: task k8s:cluster:start"
        fi

  k8s:cluster:reset:
    desc: "Reset Kubernetes cluster (stop, remove, and start fresh)"
    cmds:
      - task: k8s:cluster:stop
      - task: k8s:cluster:start

  k8s:cluster:load:
    desc: "Load timer image into Kubernetes cluster"
    cmds:
      - |
        echo "Loading {{.SERVICE_NAME}}:{{.IMAGE_TAG}} into cluster..."
        podman save {{.SERVICE_NAME}}:{{.IMAGE_TAG}} | podman exec -i kind-control-plane ctr -n k8s.io images import -

  # Regular Kubernetes tasks
  k8s:apply:
    desc: "Apply timer Kubernetes resources"
    cmds:
      - kubectl apply -f k8s/

  k8s:delete:
    desc: "Delete timer Kubernetes resources"
    cmds:
      - kubectl delete -f k8s/ --ignore-not-found=true

  k8s:logs:
    desc: "Show timer logs in Kubernetes"
    cmds:
      - kubectl logs -l app=timer-service --tail=100 -f

  k8s:status:
    desc: "Show timer status in Kubernetes"
    cmds:
      - kubectl get jobs,pods -l app=timer-service

  # Deployment
  deploy:
    desc: "Deploy timer (build + push + apply)"
    cmds:
      - task: container:build
      - task: container:push
      - task: k8s:apply

  deploy:local:
    desc: "Deploy timer to local Kubernetes cluster"
    cmds:
      - echo "Building container image..."
      - task: container:build
      - echo "Loading image into local cluster..."
      - task: k8s:cluster:load
      - echo "Applying Kubernetes resources..."
      - task: k8s:apply
      - echo "Local deployment complete!"

  deploy:dev:
    desc: "Full development deployment (cluster + app)"
    cmds:
      - echo "Starting local Kubernetes cluster..."
      - task: k8s:cluster:start
      - echo "Building and deploying timer..."
      - task: deploy:local
      - echo "Checking deployment status..."
      - task: k8s:status

  deploy:script:
    desc: "Deploy using deploy script"
    cmds:
      - ./scripts/deploy.sh

  # Health and monitoring
  health:
    desc: "Check timer health"
    cmds:
      - cargo run -- health

  grpc:check:
    desc: "Check running timer via gRPC using grpcurl"
    env:
      TIMER_ID: '{{.TIMER_ID | default "dev-timer"}}'
      GRPC_HOST: '{{.GRPC_HOST | default "localhost:50051"}}'
    cmds:
      - |
        echo "Checking timer '$TIMER_ID' on $GRPC_HOST..."
        if ! lsof -i :50051 > /dev/null 2>&1; then
          echo "ERROR: No service running on port 50051"
          echo "Start the timer service first with: task run"
          exit 1
        fi
        grpcurl -plaintext \
          -import-path ../../proto/timer \
          -proto ctrlsys/timer/v1/timer.proto \
          -d '{"timer_id": "'$TIMER_ID'"}' \
          $GRPC_HOST \
          ctrlsys.timer.v1.TimerService/CheckTimer

  grpc:stream:
    desc: "Stream timer status via gRPC using grpcurl"
    env:
      TIMER_ID: '{{.TIMER_ID | default "dev-timer"}}'
      GRPC_HOST: '{{.GRPC_HOST | default "localhost:50051"}}'
    cmds:
      - |
        echo "Streaming timer '$TIMER_ID' from $GRPC_HOST (Press Ctrl+C to stop)..."
        if ! lsof -i :50051 > /dev/null 2>&1; then
          echo "ERROR: No service running on port 50051"
          echo "Start the timer service first with: task run"
          exit 1
        fi
        grpcurl -plaintext \
          -import-path ../../proto/timer \
          -proto ctrlsys/timer/v1/timer.proto \
          -d '{"timer_id": "'$TIMER_ID'"}' \
          $GRPC_HOST \
          ctrlsys.timer.v1.TimerService/StreamTimer

  grpc:describe:
    desc: "Describe timer gRPC service using grpcurl"
    cmds:
      - |
        echo "Timer service methods:"
        grpcurl -plaintext \
          -import-path ../../proto/timer \
          -proto ctrlsys/timer/v1/timer.proto \
          describe ctrlsys.timer.v1.TimerService

  # Cleanup
  clean:
    desc: "Clean timer build artifacts"
    cmds:
      - cargo clean
      - rm -rf target/

  logs:
    desc: "Show local timer logs"
    cmds:
      - tail -f /tmp/timer-service.log || echo "No log file found"

  # Development shortcuts
  dev:
    desc: "Quick development cycle"
    cmds:
      - task: check
      - task: run:debug
